## Access Modifiers
snippet po
	protected
snippet pu
	public
snippet pr
	private
##
## Annotations
snippet before
	@Before
	static void ${1:intercept}(${2:args}) { ${3} }
snippet mm
	@ManyToMany
	${1}
snippet mo
	@ManyToOne
	${1}
snippet om
	@OneToMany${1:(cascade=CascadeType.ALL)}
	${2}
snippet oo
	@OneToOne
	${1}
##
## Basic Java packages and import
snippet im
	import
snippet j.b
	java.beans.
snippet j.i
	java.io.
snippet j.m
	java.math.
snippet j.n
	java.net.
snippet j.u
	java.util.
##
## Class
snippet cl
	class ${1:`Filename("", "untitled")`} ${2}
snippet in
	interface ${1:`Filename("", "untitled")`} ${2:extends Parent}${3}
snippet tc
	public class ${1:`Filename()`} extends ${2:TestCase}
##
## Exception Handling
snippet as
	assert ${1:test} : "${2:Failure message}";${3}
snippet ca
	catch(${1:Exception} ${2:e}) ${3}
snippet thr
	throw
snippet ths
	throws
snippet try
	try {
		${3}
	} catch(${1:Exception} ${2:e}) {
	}
snippet tryf
	try {
		${3}
	} catch(${1:Exception} ${2:e}) {
	} finally {
	}
##
## Find Methods
snippet findall
	List<${1:listName}> ${2:items} = ${1}.findAll();${3}
snippet findbyid
	${1:var} ${2:item} = ${1}.findById(${3});${4}
##
## Javadocs
snippet /**
	/**
	 * ${1}
	 */
snippet @au
	@author `system("grep \`id -un\` /etc/passwd | cut -d \":\" -f5 | cut -d \",\" -f1")`
snippet @br
	@brief ${1:Description}
snippet @fi
	@file ${1:`Filename()`}.java
snippet @pa
	@param ${1:param}
snippet @re
	@return ${1:param}

############################ added by me	
snippet class:public_abstract_class
	${1:public} ${2:abstract} ${3:class} ${4:`Filename()`} {
		${2:/* your code */}	
	}

snippet class:extends
	${1:public} ${2:interface/class} ${2:`Filename()`} extends ${3:ExtendedClassName} {
		${4:/* your code */}	
	}

snippet class:implements
	${1:public} class ${2:`Filename()`} implements ${3:InterfaceName} {
		${4:/* your code */}
	}

snippet class:thread
	${1:ClassType} class ${2:`Filename()`} extends Thread {

		@Override
		public void run() {
			${3:/* your code */}
		}

	}

snippet method:synchronized
	synchronized ${1:public} ${2:void} ${3:function}(${4:parameters}) {
		${5:/* your code */}	
	}

snippet method:main
	public static void main (String[] args) {
		${1:/* code */}
	}

snippet array:new_array Without initialize
	${1:byte}[] ${2:name} = new $1[${3:64*1024}];

snippet array:new_array With initialize
	${1:byte}[] ${2:name} = new $1[]{${3:'a', 'b', 'c'}};
	
snippet prefix:static_final
	${1:public} static final ${2:}

snippet flow:while
	while(${1:true}) {
		${2:/* your code */}
	}

snippet flow:if
	if(${1:true}) {
		${2:/* your code */}
	}

snippet flow:for
	for (${1:int i = 0}; ${2:i >= 0}; ${3:i--}) {
		${4:/* your code */}
	}

snippet flow:forEach
	for (${1:Long} ${2:id} : ${3:set}) {
		${4:/* your code */}
	}

snippet exception:throw_new
	throw new ${1:ExceptionName}(${2:});

snippet log:slf4j_init
	static final Logger LOG = LoggerFactory.getLogger(${1:ClassName.class});
	${2:/* LOG.debug("log ()  and ()", obj1, obj2); LOG.info(), warn, error*/}

snippet container:set

snippet variable:atomic
	${1:private} Atomic${2:Integer/Boolean/Long/IntegerArray/LongArray/Reference/ReferenceArray} ${3:variablename} = new Atomic$2(${4:initialValue});
	${5:}

snippet atomic.addAndGet
	int ${1:result} = ${2:atomic}.addAndGet(${3:int delta});
	${4:/* Atomically adds the given value to the current value. */}

snippet atomic.decrementAndGet
	int ${1:result} = ${2:atomic}.decrementAndGet();
	${3:/* Atomically decrements by one the current value. */}

snippet atomic.doubleValue
	double ${1:result} = ${2:atomic}.doubleValue();
	${3:/* Returns the value of the specified number as a double. */}

snippet atomic.floatValue
	float ${1:result} = ${2:atomic}.floatValue();
	${3:/* Returns the value of the specified number as a float. */}

snippet atomic.get
	int ${1:result} = ${2:atomic}.get();
	${3:/* Get the current value. */}

snippet atomic.getAndAdd
	int ${1:result} = ${2:atomic}.getAndAdd(${3:int delta});
	${3:/* atomically adds the given value to the current value. */}

snippet atomic.getAndDecrement
	${1:atomic}.getAndDecrement();
	${2:}

snippet atomic.getAndIncrement
	${1:atomic}.getAndIncrement();
	${2:}

snippet atomic.getAndSet
	${1:atomic}.getAndSet(${2:int newValue});
	${2:}

snippet atomic.incrementAndGet
	${1:atomic}.incrementAndGet();
	${2:}

snippet atomic.intValue
	${1:atomic}.intValue();
	${2:/* returns the value of the specified number as an int. */}

snippet atomic.lazySet
	${1:atomic}.lazySet(${2:int newValue});
	${3:/* Eventually sets to the given value. */}

snippet atomic.longValue
	${1:atomic}.longValue();
	${2:/* returns the value of the specified number as a long. */}

snippet atomic.set
	${1:atomic}.set(${2:int newValue});	
	${3:}

snippet atomic.toString
	${1:atomic}.toString();

snippet atomic.weakCompareAndSet
	${1:atomic}.weakCompareAndSet(${2:int expect}, ${3:int update});
	${4:/* may fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet. */}

snippet atomic.compareAndSet
	boolean ${1:result} = ${2:atomic}.compareAndSet(${3:int expect}, ${4:int update});
	${5:/* Atomically sets the value to the given updated value if the current value == the expected value.}

snippet concurrent:synchronized
	synchronized (${1:this}) {
		${2:/* your code */}
	}
	${3:}
	
snippet concurrent:CountDownLatch
	Sample usage: 
	class Driver {
		void main() throw InterruptedException {
			CountDownLatch startSignal = new CountDownLatch(1);
			CountDownLatch doneSignal = new CountDownLatch(N);

			for (int i = 0; i < N; i++) {
				new Thread(new Worker(startSignal, doneSignal)).start();
			}

			doSomethingElse();
			startSignal.countDown();
			doSomethingElse();
			doneSignal.await();
		}
	}

	class Worker implements Runnable {
		private final CountDownLatch startSignal;
		private final CountDownLatch doneSignal;

		Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
			this.startSignal = startSignal;
			this.doneSignal = doneSignal;
		}

		public void run() {
			try {
				startSignal.await();
				doWork();
				doneSignal.countDown();
			} catch (InterruptedException ex) {}
		}

		void doWork() { ... }
	}
	${1:/*A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. The count cannot be reset, if you need a versioin that resets the count, consider using a CyclicBarrier.*/}

snippet concurrent:Future
	static class CountDownLatchFuture<T> implements Future<T> {
		T value = null;
		volatile boolean done = false;
		CountDownLatch latch = new CountDownLatch(1);

		@Override
		public boolean cancel(boolean mayInterruptIfRunning) { return false; }

		@Override
		public T get() throws InterruptedException {
			latch.await();
			return value;
		}

		@Override
		public T get(long timeout, TimeUnit unit)
			throws InterruptedException, TimeoutException {
			if (!latch.await(timeout, unit)) {
				throw new TimeoutException("Timed out waiting for latch");
			}
			return value;
		}

		@Override
		public boolean isCancelled() { return false; }

		@Override
		public boolean isDone() { return done; }

		void setDone(T value) {
			this.value = value;
			done = true;
			latch.countDown();
		}
	}
	${1:/*A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future<?> and return null as a result of the underlying task.*/}
